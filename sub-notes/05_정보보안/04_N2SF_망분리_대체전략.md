# N2SF 기반 망분리 대체 전략

## 1. 정의 및 배경

### 1.1 정의
**N2SF(National Network Security Framework)**는 기존 물리적 망분리를 **논리적 다계층 보안**으로 대체하는 국가 차원의 네트워크 보안 프레임워크다. C/S/O(Confidential/Sensitive/Open) 3계층 보안 모델을 통해 업무 효율성과 보안성을 동시에 확보한다.

### 1.2 출제 배경
- **정책**: 행안부 2025년까지 공공기관 N2SF 전환 의무화
- **문제**: 137회 N2SF 개념 출제 ← 국가 보안 정책 전환점
- **근본 원인**: 물리적 망분리의 업무 효율성 저하 + 클라우드 시대 부적합
  - 자료 반출입 지연 (USB, 망연계 신청)
  - 이중 인프라 운영 비용 (2배)
  - 클라우드/모바일 근무 불가능

### 1.3 필요성
1. **업무 효율성**: 망간 자료 전송 시간 90% 단축 (24시간 → 2시간)
2. **비용 절감**: 네트워크 장비 통합 → 인프라 비용 40% 절감
3. **클라우드 전환**: 공공 클라우드 100% 전환 정책(2025)의 선제 조건
4. **제로트러스트 호환**: 경계 기반 → 정체성 기반 보안 패러다임 전환

---

## 2. 기존 망분리의 문제점

### 2.1 물리적 망분리 구조

```
[기존 망분리 아키텍처]

┌─────────────────┐              ┌─────────────────┐
│  업무망 (내부)   │              │  인터넷망 (외부) │
│                 │              │                 │
│ ┌─────────┐     │              │ ┌─────────┐     │
│ │ 업무 PC │     │              │ │인터넷 PC│     │
│ └─────────┘     │              │ └─────────┘     │
│       ↓         │              │       ↓         │
│ ┌─────────┐     │   망연계    │ ┌─────────┐     │
│ │업무 서버│←────┼──── SBC ────┼→│웹 서버  │     │
│ └─────────┘     │   (수동승인) │ └─────────┘     │
│                 │              │                 │
└─────────────────┘              └─────────────────┘
     물리적 분리                      물리적 분리
```

### 2.2 주요 문제점

| 문제 | 세부 내용 | 영향 |
|------|-----------|------|
| **업무 지연** | 망연계 신청 → 보안 담당자 승인 → 전송 (24~48시간) | 의사결정 지연 |
| **이중 인프라** | 스위치, 라우터, 서버 2배 구축 | 예산 낭비 |
| **우회 공격** | USB, 물리 반출 → 악성코드 감염 | 보안 취약점 |
| **클라우드 불가** | 외부 클라우드 연결 차단 | 디지털 전환 저해 |
| **재택근무 불가** | VDI 성능 저하 (지연시간 200ms+) | 유연 근무 제한 |

### 2.3 실제 사례

```
[A 공공기관 망연계 프로세스]

1. 직원: 인터넷망 자료를 업무망으로 전송 요청 (09:00)
2. 보안팀: 파일 스캔 + 승인 검토 (09:00~17:00)
3. 전송: 망연계 서버(SBC)를 통해 수동 복사 (17:30)
4. 직원: 자료 수신 확인 (다음날 09:00)

→ 총 소요 시간: 24시간 (실제 전송 시간 5분)
```

---

## 3. N2SF 아키텍처 상세

### 3.1 C/S/O 3계층 모델

```
[N2SF 논리적 다계층 보안 아키텍처]

┌────────────────────────────────────────────────────────┐
│                   통합 네트워크 인프라                   │
└────────────────────────────────────────────────────────┘
                         ↓
        ┌────────────────┼────────────────┐
        ↓                ↓                ↓
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ C (기밀)     │  │ S (민감)     │  │ O (일반)     │
│ Confidential │  │ Sensitive    │  │ Open         │
├──────────────┤  ├──────────────┤  ├──────────────┤
│ • 국가기밀   │  │ • 개인정보   │  │ • 공개정보   │
│ • 주민번호   │  │ • 내부문서   │  │ • 홈페이지   │
│ • 국방정보   │  │ • 재무자료   │  │ • 공지사항   │
├──────────────┤  ├──────────────┤  ├──────────────┤
│ 보안등급: 1급│  │ 보안등급: 2급│  │ 보안등급: 3급│
│ 접근: MFA +  │  │ 접근: MFA    │  │ 접근: ID/PW  │
│       생체인증│  │              │  │              │
│ 암호화: AES  │  │ 암호화: AES  │  │ 암호화: TLS  │
│       -256   │  │       -128   │  │              │
└──────────────┘  └──────────────┘  └──────────────┘
```

### 3.2 계층별 보안 정책

#### C 계층 (Confidential - 기밀)
```yaml
접근제어:
  - 인증: MFA(Multi-Factor Authentication) + 생체인증
  - 인가: RBAC(Role-Based) + ABAC(Attribute-Based) 결합
  - 네트워크: 마이크로세그멘테이션 (Pod 단위 격리)

데이터보호:
  - 저장: AES-256 암호화 + HSM 키 관리
  - 전송: mTLS (Mutual TLS) + Perfect Forward Secrecy
  - 출력: 워터마크 + DRM (문서 유출 추적)

모니터링:
  - 접근 로그: 실시간 SIEM 연동
  - 이상탐지: UEBA(User Entity Behavior Analytics)
  - 감사: 6개월 로그 보관 + 법적 책임 추적
```

#### S 계층 (Sensitive - 민감)
```yaml
접근제어:
  - 인증: MFA (OTP, 인증서)
  - 인가: RBAC 기반
  - 네트워크: VLAN 분리 + NAC

데이터보호:
  - 저장: AES-128 암호화
  - 전송: TLS 1.3
  - 출력: 로그 기록

모니터링:
  - 접근 로그: 일 단위 수집
  - 이상탐지: 규칙 기반
  - 감사: 3개월 로그 보관
```

#### O 계층 (Open - 일반)
```yaml
접근제어:
  - 인증: ID/Password
  - 인가: 기본 ACL
  - 네트워크: 방화벽 기본 정책

데이터보호:
  - 저장: 평문 허용
  - 전송: HTTPS
  - 출력: 제한 없음

모니터링:
  - 접근 로그: 주 단위 수집
  - 이상탐지: 수동 검토
  - 감사: 1개월 로그 보관
```

### 3.3 핵심 기술 구성요소

#### (1) SDP (Software Defined Perimeter)

```
[SDP 동작 흐름]

1. 사용자 인증 전: 네트워크 "암흑(Dark)" 상태
   ┌──────┐         ┌──────────┐
   │ 사용자 │ ─(?)─→ │    서버   │  (응답 없음)
   └──────┘         └──────────┘

2. SDP Controller에 인증
   ┌──────┐                   ┌─────────────┐
   │ 사용자 │ ──── MFA ────→  │ SDP Controller│
   └──────┘                   └─────────────┘
                                      ↓
                              ┌─────────────┐
                              │ 정책 엔진    │
                              │ - 사용자 ID  │
                              │ - 단말 신뢰성 │
                              │ - 위치 정보   │
                              └─────────────┘

3. 인증 성공 → Gateway 동적 개방
   ┌──────┐         ┌──────────┐         ┌──────┐
   │ 사용자 │ ←─────→ │ SDP Gateway │ ←────→ │ 서버 │
   └──────┘  (mTLS)  └──────────┘  (터널)  └──────┘
                      ↑
                  단일 패킷만 허용 (Single Packet Authorization)
```

**SDP 구현 코드 (Python)**:
```python
class SDPController:
    def authenticate_user(self, user_credentials):
        """사용자 인증 및 정책 결정"""
        # 1. 다요소 인증
        mfa_verified = self.verify_mfa(
            user_credentials['username'],
            user_credentials['otp']
        )

        # 2. 디바이스 신뢰성 검증
        device_posture = self.check_device_posture(
            user_credentials['device_id']
        )
        if not device_posture['compliant']:
            raise SecurityException("Device not compliant")

        # 3. 컨텍스트 기반 접근 제어
        context = {
            'user_role': self.get_user_role(user_credentials['username']),
            'location': user_credentials['ip_geolocation'],
            'time': datetime.now(),
            'device_type': device_posture['device_type']
        }

        # 4. 정책 평가 (ABAC)
        allowed_resources = self.policy_engine.evaluate(context)

        # 5. Gateway에 동적 규칙 추가
        for resource in allowed_resources:
            self.sdp_gateway.add_firewall_rule(
                user_id=user_credentials['username'],
                src_ip=user_credentials['ip'],
                dst_ip=resource['ip'],
                dst_port=resource['port'],
                protocol='tcp',
                ttl=3600  # 1시간 후 자동 삭제
            )

        return {'status': 'authorized', 'resources': allowed_resources}

class SDPGateway:
    def add_firewall_rule(self, user_id, src_ip, dst_ip, dst_port, protocol, ttl):
        """동적 방화벽 규칙 추가 (eBPF 기반)"""
        # eBPF를 이용한 커널 레벨 패킷 필터링
        bpf_program = f"""
        if (src_ip == {src_ip} && dst_ip == {dst_ip} && dst_port == {dst_port}):
            return ALLOW
        """
        self.ebpf_manager.load_program(bpf_program)

        # TTL 기반 자동 삭제 스케줄링
        self.scheduler.add_job(
            func=self.remove_firewall_rule,
            args=[user_id, src_ip, dst_ip],
            trigger='date',
            run_date=datetime.now() + timedelta(seconds=ttl)
        )
```

#### (2) ZTNA (Zero Trust Network Access)

```
[ZTNA vs VPN 비교]

기존 VPN:
1. 사용자 인증 → 네트워크 전체 접근 가능
   ┌──────┐         ┌─────────────────────────┐
   │ 사용자 │ ──VPN─→ │ 내부 네트워크 전체 접근 │
   └──────┘         │ - 모든 서버             │
                    │ - 모든 DB               │
                    │ - 모든 파일 공유        │
                    └─────────────────────────┘
   문제: 수평 이동 공격 (Lateral Movement) 가능

ZTNA:
1. 사용자 인증 → 특정 애플리케이션만 접근
   ┌──────┐         ┌──────────┐
   │ 사용자 │ ──ZTNA─→│ App A만  │
   └──────┘         └──────────┘
                    (다른 리소스 불가시)
   장점: 최소 권한 원칙 (Least Privilege)
```

**ZTNA 정책 엔진 (OPA 기반)**:
```rego
# Open Policy Agent (OPA) 정책 정의

package n2sf

# C 계층 접근 정책
allow_confidential {
    input.user.mfa_verified == true
    input.user.biometric_verified == true
    input.user.security_clearance >= 1
    input.device.compliant == true
    input.device.encrypted == true
    input.location in ["office", "secure_vpn"]
    input.time.hour >= 9
    input.time.hour <= 18
}

# S 계층 접근 정책
allow_sensitive {
    input.user.mfa_verified == true
    input.user.security_clearance >= 2
    input.device.compliant == true
}

# O 계층 접근 정책
allow_open {
    input.user.authenticated == true
}

# 최종 결정
decision := {
    "allowed": allow_confidential or allow_sensitive or allow_open,
    "layer": layer,
    "reason": reason
}
```

#### (3) 마이크로세그멘테이션

```
[마이크로세그멘테이션 구현 - Cilium + eBPF]

기존 VLAN 방식:
┌────────────────────────────────────────┐
│             VLAN 10 (업무망)            │
│  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐   │
│  │App A│  │App B│  │App C│  │  DB │   │
│  └─────┘  └─────┘  └─────┘  └─────┘   │
│    ↔        ↔        ↔        ↔        │
│         모든 서비스 간 통신 허용        │
└────────────────────────────────────────┘

N2SF 마이크로세그멘테이션:
┌─────┐         ┌─────┐         ┌─────┐
│App A│ ─✓→     │App B│ ─✓→     │  DB │
│(C)  │         │(S)  │         │ (C) │
└─────┘         └─────┘         └─────┘
   ↓ ✗              ↓ ✗              ↑
   └───────────────→└────────────────✗
      (차단)           (차단)

정책: App A는 App B만 접근, App B는 DB만 접근
```

**Cilium NetworkPolicy 예시**:
```yaml
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: c-layer-isolation
spec:
  # C 계층 Pod에 적용
  endpointSelector:
    matchLabels:
      security-layer: confidential

  # Ingress (수신) 정책
  ingress:
  - fromEndpoints:
    - matchLabels:
        security-layer: confidential
        app: authorized-client
    toPorts:
    - ports:
      - port: "443"
        protocol: TCP
      rules:
        http:
        - method: "GET|POST"
          path: "/api/v1/.*"

  # Egress (발신) 정책
  egress:
  - toEndpoints:
    - matchLabels:
        security-layer: confidential
        app: database
    toPorts:
    - ports:
      - port: "5432"
        protocol: TCP

  # DNS 허용 (필수)
  - toEndpoints:
    - matchLabels:
        k8s:io.kubernetes.pod.namespace: kube-system
        k8s:k8s-app: kube-dns
    toPorts:
    - ports:
      - port: "53"
        protocol: UDP

  # 기본 정책: 모든 다른 통신 차단 (Default Deny)
```

---

## 4. 망분리 → N2SF 전환 전략

### 4.1 단계별 마이그레이션

```
[4단계 전환 로드맵]

┌─────────────────────────────────────────────────────────────┐
│ Phase 1: 평가 및 설계 (3개월)                                │
├─────────────────────────────────────────────────────────────┤
│ • 현행 망분리 구조 분석                                      │
│ • 자산 분류 (C/S/O 등급 부여)                                │
│ • 보안 정책 설계                                             │
│ • PoC (Proof of Concept) 수행                                │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ Phase 2: 파일럿 구축 (3개월)                                 │
├─────────────────────────────────────────────────────────────┤
│ • 비핵심 시스템 우선 적용 (O 계층)                           │
│ • SDP, ZTNA 솔루션 배포                                       │
│ • 네트워크 정책 테스트                                        │
│ • 사용자 교육                                                │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ Phase 3: 단계적 전환 (6개월)                                 │
├─────────────────────────────────────────────────────────────┤
│ • S 계층 전환 (개인정보 시스템)                              │
│ • C 계층 전환 (국가기밀 시스템)                              │
│ • 하이브리드 운영 (망분리 + N2SF 병행)                       │
│ • 지속적 모니터링 및 정책 조정                               │
└─────────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ Phase 4: 완전 전환 및 안정화 (3개월)                         │
├─────────────────────────────────────────────────────────────┤
│ • 기존 망분리 장비 철거                                      │
│ • N2SF 전용 운영 체계 확립                                   │
│ • 보안 감사 및 인증 획득                                     │
│ • 운영 매뉴얼 정비                                           │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 자산 분류 기준

```python
class AssetClassifier:
    """N2SF 자산 분류 엔진"""

    def classify_asset(self, asset):
        """자산을 C/S/O 계층으로 분류"""
        score = 0

        # 1. 데이터 민감도
        if '주민등록번호' in asset['data_fields']:
            score += 100  # C 계층 확정
        elif '개인정보' in asset['data_fields']:
            score += 50   # S 계층 후보

        # 2. 법적 요구사항
        if asset['compliance'] in ['국가기밀', '국방정보']:
            score += 100
        elif asset['compliance'] in ['개인정보보호법', 'ISMS-P']:
            score += 50

        # 3. 영향도 분석
        breach_impact = self.assess_breach_impact(asset)
        if breach_impact == 'critical':
            score += 100
        elif breach_impact == 'high':
            score += 50

        # 4. 접근 빈도
        if asset['access_frequency'] > 1000:  # 일 1000회 이상
            # 고빈도 접근 시스템은 O 계층 우선 (사용성)
            score -= 20

        # 분류 결정
        if score >= 100:
            return 'C'
        elif score >= 50:
            return 'S'
        else:
            return 'O'

    def assess_breach_impact(self, asset):
        """침해 시 영향도 평가 (CIA 기반)"""
        cia_score = {
            'confidentiality': 0,
            'integrity': 0,
            'availability': 0
        }

        # 기밀성 (Confidentiality)
        if '국가기밀' in asset['classification']:
            cia_score['confidentiality'] = 10
        elif '개인정보' in asset['classification']:
            cia_score['confidentiality'] = 7

        # 무결성 (Integrity)
        if asset['type'] == '금융거래':
            cia_score['integrity'] = 10
        elif asset['type'] == '공문서':
            cia_score['integrity'] = 7

        # 가용성 (Availability)
        if asset['criticality'] == '24/7':
            cia_score['availability'] = 10

        total_score = sum(cia_score.values())

        if total_score >= 25:
            return 'critical'
        elif total_score >= 15:
            return 'high'
        elif total_score >= 5:
            return 'medium'
        else:
            return 'low'
```

### 4.3 하이브리드 운영 전략

```
[전환 기간 중 망분리 + N2SF 병행 운영]

┌─────────────────────────────────────────────────────────┐
│                    외부 인터넷                           │
└─────────────────┬───────────────────────────────────────┘
                  │
        ┌─────────┴─────────┐
        │   통합 Gateway    │
        │  (SDP Controller) │
        └─────────┬─────────┘
                  │
      ┌───────────┼───────────┐
      ↓                       ↓
┌──────────────┐        ┌──────────────┐
│ 기존 망분리   │        │   N2SF 환경  │
│  (레거시)    │        │   (신규)     │
├──────────────┤        ├──────────────┤
│ • 물리 분리   │        │ • C 계층     │
│ • SBC 연계   │        │ • S 계층     │
│ • VDI 접근   │        │ • O 계층     │
└──────────────┘        └──────────────┘
      ↓                       ↓
  [ 70% 트래픽 ]        [ 30% 트래픽 ]
      ↓                       ↓
  단계적 감소             단계적 증가
```

---

## 5. 기술 구현 상세

### 5.1 디바이스 신뢰성 검증 (Device Trust)

```python
class DevicePostureCheck:
    """단말 신뢰성 검증 (Endpoint Compliance)"""

    def check_compliance(self, device_id):
        """단말이 보안 정책을 준수하는지 검증"""
        checks = {
            'os_version': self.check_os_version(device_id),
            'antivirus': self.check_antivirus(device_id),
            'encryption': self.check_disk_encryption(device_id),
            'patches': self.check_security_patches(device_id),
            'firewall': self.check_firewall_enabled(device_id),
            'jailbreak': self.check_jailbreak(device_id)
        }

        # 점수 계산
        score = sum(1 for v in checks.values() if v['passed'])
        total = len(checks)

        compliance_rate = score / total

        if compliance_rate >= 0.9:
            access_level = 'C'  # 기밀 접근 가능
        elif compliance_rate >= 0.7:
            access_level = 'S'  # 민감 정보만
        elif compliance_rate >= 0.5:
            access_level = 'O'  # 일반 정보만
        else:
            access_level = 'DENY'  # 접근 거부

        return {
            'compliant': compliance_rate >= 0.5,
            'access_level': access_level,
            'checks': checks,
            'compliance_rate': compliance_rate
        }

    def check_os_version(self, device_id):
        """OS 버전이 최신인지 확인"""
        device = self.get_device_info(device_id)

        min_versions = {
            'Windows': '10.0.19045',  # Windows 10 22H2
            'macOS': '13.0',          # Ventura
            'iOS': '16.0',
            'Android': '12.0'
        }

        os_type = device['os_type']
        current_version = device['os_version']

        if os_type in min_versions:
            required = min_versions[os_type]
            passed = self.version_compare(current_version, required) >= 0
        else:
            passed = False

        return {
            'passed': passed,
            'current': current_version,
            'required': min_versions.get(os_type, 'unknown')
        }

    def check_disk_encryption(self, device_id):
        """디스크 암호화 활성화 여부"""
        device = self.get_device_info(device_id)

        # Windows: BitLocker, macOS: FileVault, Linux: LUKS
        encryption_tools = {
            'Windows': 'BitLocker',
            'macOS': 'FileVault',
            'Linux': 'LUKS'
        }

        tool = encryption_tools.get(device['os_type'])
        enabled = self.check_encryption_tool(device_id, tool)

        return {
            'passed': enabled,
            'tool': tool,
            'status': 'enabled' if enabled else 'disabled'
        }
```

### 5.2 실시간 모니터링 (UEBA)

```python
class UEBAEngine:
    """사용자 행위 기반 이상 탐지"""

    def analyze_user_behavior(self, user_id, event):
        """사용자 행위 패턴 분석 및 이상 탐지"""
        # 1. 정상 베이스라인 조회
        baseline = self.get_user_baseline(user_id)

        # 2. 이상 점수 계산
        anomaly_score = 0

        # (1) 비정상 시간대 접근
        if not self.is_normal_work_hour(event['timestamp'], baseline):
            anomaly_score += 30

        # (2) 비정상 위치
        if event['location'] not in baseline['usual_locations']:
            anomaly_score += 40

        # (3) 과도한 데이터 다운로드
        if event['data_download'] > baseline['avg_download'] * 10:
            anomaly_score += 50

        # (4) 권한 상승 시도
        if event['privilege_escalation']:
            anomaly_score += 80

        # (5) C 계층 과도 접근
        c_layer_access = self.count_c_layer_access(user_id, time_window='1hour')
        if c_layer_access > baseline['avg_c_access'] * 5:
            anomaly_score += 60

        # 3. 위험도 판단
        if anomaly_score >= 100:
            risk_level = 'critical'
            action = 'BLOCK_AND_ALERT'
        elif anomaly_score >= 60:
            risk_level = 'high'
            action = 'MFA_CHALLENGE'
        elif anomaly_score >= 30:
            risk_level = 'medium'
            action = 'LOG_AND_MONITOR'
        else:
            risk_level = 'low'
            action = 'ALLOW'

        # 4. 대응 조치
        if action == 'BLOCK_AND_ALERT':
            self.block_user_session(user_id)
            self.send_alert_to_soc(user_id, event, anomaly_score)
        elif action == 'MFA_CHALLENGE':
            self.request_additional_auth(user_id)

        return {
            'risk_level': risk_level,
            'anomaly_score': anomaly_score,
            'action': action
        }
```

### 5.3 데이터 계층 간 이동 제어

```
[계층 간 데이터 이동 정책]

O → S: 자동 승인 (상향 이동)
   ┌─────┐         ┌─────┐
   │  O  │ ──✓→   │  S  │
   └─────┘         └─────┘

S → C: 승인 필요 + DLP 스캔
   ┌─────┐         ┌─────┐
   │  S  │ ──?→   │  C  │
   └─────┘         └─────┘
                     ↑
              ┌──────┴──────┐
              │ 1. DLP 스캔  │
              │ 2. 관리자 승인│
              └──────────────┘

C → S: 엄격한 통제 + 워터마크
   ┌─────┐         ┌─────┐
   │  C  │ ──!→   │  S  │
   └─────┘         └─────┘
                     ↑
              ┌──────┴──────┐
              │ 1. DLP 스캔  │
              │ 2. 워터마크   │
              │ 3. 책임자 승인│
              │ 4. 감사 로그  │
              └──────────────┘

S/C → O: 원칙적 차단
   ┌─────┐         ┌─────┐
   │ S/C │ ──✗→   │  O  │
   └─────┘         └─────┘
   (예외: 공개 승인된 자료만 허용)
```

**DLP(Data Loss Prevention) 구현**:
```python
class DLPEngine:
    """데이터 유출 방지 엔진"""

    def scan_data_transfer(self, transfer_request):
        """계층 간 데이터 전송 시 스캔"""
        src_layer = transfer_request['source_layer']
        dst_layer = transfer_request['destination_layer']
        data = transfer_request['data']

        # 1. 전송 방향 검증
        if not self.is_allowed_direction(src_layer, dst_layer):
            return {
                'allowed': False,
                'reason': f'Transfer from {src_layer} to {dst_layer} is blocked'
            }

        # 2. 민감 데이터 탐지
        sensitive_patterns = {
            'ssn': r'\d{6}-\d{7}',  # 주민등록번호
            'credit_card': r'\d{4}-\d{4}-\d{4}-\d{4}',
            'email': r'[\w\.-]+@[\w\.-]+\.\w+',
            'ip_address': r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'
        }

        detected_patterns = []
        for pattern_name, regex in sensitive_patterns.items():
            matches = re.findall(regex, data)
            if matches:
                detected_patterns.append({
                    'type': pattern_name,
                    'count': len(matches)
                })

        # 3. 정책 적용
        if src_layer == 'C' and dst_layer in ['S', 'O']:
            # C 계층 데이터 외부 전송 시
            if detected_patterns:
                # 워터마크 삽입
                watermarked_data = self.add_watermark(
                    data,
                    user_id=transfer_request['user_id'],
                    timestamp=datetime.now()
                )

                # 관리자 승인 대기
                approval_id = self.request_approval(
                    transfer_request,
                    detected_patterns
                )

                return {
                    'allowed': False,
                    'pending_approval': approval_id,
                    'detected_patterns': detected_patterns,
                    'watermarked_data': watermarked_data
                }

        return {'allowed': True}

    def add_watermark(self, data, user_id, timestamp):
        """문서에 워터마크 추가 (유출 추적용)"""
        watermark = f"""
        ──────────────────────────────
        기밀 문서 - 무단 배포 금지
        사용자: {user_id}
        출력일시: {timestamp}
        추적ID: {uuid.uuid4()}
        ──────────────────────────────
        """
        return watermark + data
```

---

## 6. 성능 및 보안 분석

### 6.1 망분리 vs N2SF 비교

| 항목 | 기존 망분리 | N2SF | 개선율 |
|------|-------------|------|--------|
| **업무 효율성** |
| 자료 전송 시간 | 24시간 | 2시간 | 92% ↑ |
| 재택근무 지원 | 불가 (VDI 한정) | 가능 | - |
| 클라우드 연동 | 불가 | 가능 | - |
| **비용** |
| 네트워크 장비 | 2배 (이중 구축) | 1배 | 50% ↓ |
| 운영 인력 | 10명 | 6명 | 40% ↓ |
| 전력 소비 | 200kW | 120kW | 40% ↓ |
| **보안** |
| USB 우회 공격 | 취약 | 차단 (DLP) | - |
| 내부자 위협 | 탐지 어려움 | UEBA 탐지 | - |
| 감사 추적 | 제한적 | 완전 | - |

### 6.2 실제 도입 사례

#### A 공공기관 (2024년 파일럿)

**Before (망분리)**:
```
- 시스템: 150대 서버 (업무망 80대, 인터넷망 70대)
- 자료 전송: 일 평균 200건 → 24시간 소요
- 망연계 장비: SBC 10대 (5억원)
- 문제: 클라우드 전환 불가, 재택근무 VDI 지연
```

**After (N2SF)**:
```
- 시스템: 150대 서버 → 통합 네트워크
- 자료 전송: 일 평균 200건 → 2시간 소요 (자동 승인 80%)
- 보안 솔루션: SDP + ZTNA (3억원)
- 효과:
  ✓ 업무 효율성 90% 향상
  ✓ 인프라 비용 40% 절감
  ✓ 클라우드 전환 가능
  ✓ 재택근무 지연시간 200ms → 20ms
```

**KPI 달성**:
```python
kpi_results = {
    'user_satisfaction': 85,  # 85점 (100점 만점)
    'incident_count': 2,      # 보안 사고 2건 (경미)
    'uptime': 99.9,           # 가용성 99.9%
    'false_positive_rate': 3  # 오탐률 3%
}
```

### 6.3 보안 검증

```
[침투 테스트 결과]

테스트 항목:
1. C 계층 무단 접근 시도 (50회)
   결과: 100% 차단 ✓

2. S → O 계층 데이터 유출 시도 (30회)
   결과: DLP 탐지율 93% ✓

3. 내부자 위협 시뮬레이션 (20회)
   결과: UEBA 탐지율 85% ✓

4. 디바이스 위장 공격 (15회)
   결과: Device Trust 차단율 100% ✓

5. 수평 이동 공격 (Lateral Movement)
   결과: 마이크로세그멘테이션 차단율 95% ✓
```

---

## 7. 한계 및 개선 방향

### 7.1 현재 한계

1. **복잡도 증가**: 정책 설정 및 관리 난이도 상승
2. **초기 비용**: SDP, ZTNA 솔루션 도입 비용 (3~5억)
3. **사용자 저항**: 추가 인증 단계 → UX 불편
4. **레거시 호환**: 구형 시스템의 N2SF 연동 어려움

### 7.2 개선 방향

1. **자동화**: AI 기반 정책 자동 생성 및 조정
2. **통합 플랫폼**: SDP + ZTNA + DLP 통합 솔루션
3. **UX 개선**: SSO(Single Sign-On) + Risk-based Authentication
4. **하이브리드 아키텍처**: 레거시는 망분리 유지, 신규는 N2SF

---

## 8. 시사점

### 8.1 기술적 시사점
- **제로트러스트 진화**: 망분리 → N2SF → 완전한 제로트러스트 아키텍처
- **eBPF 활용**: 커널 레벨 보안 제어 → 성능 + 보안 동시 확보
- **정책 기반 자동화**: ABAC, OPA를 통한 동적 접근 제어

### 8.2 정책적 시사점
1. **클라우드 전환 가속화**: N2SF → 공공 클라우드 100% 전환 (2025)
2. **국제 표준 정합성**: NIST Zero Trust, ISO 27001과 호환
3. **공급망 보안**: N2SF + SBOM → 소프트웨어 공급망 관리

### 8.3 출제 예상 각도
- **137회 출제** → 138회 **구현 상세** 재출제 가능성 높음
- "N2SF의 SDP 구현 방안"
- "C/S/O 계층별 보안 정책 설계"
- "망분리에서 N2SF로 전환 시 고려사항"
- "N2SF와 제로트러스트의 관계"

---

## 참고문헌
- 행정안전부, "N2SF 가이드라인" (2024)
- NIST SP 800-207, "Zero Trust Architecture"
- CISA, "Zero Trust Maturity Model"
- 137회 정보관리기술사 기출문제
